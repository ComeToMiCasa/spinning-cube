<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Rotating ASCII Cube</title>
  <style>
	html, body {
		margin: 0;
		padding: 0;
		height: 100%;         /* or 100vh */
	}

    body {
      background: black;
      color: green;
      font-family: monospace;
      white-space: pre;
      text-align: center;
      margin: 0;
      padding: 0;
	  display: flex;
	  justify-content: center;
	  align-items: center;
    }
    #canvas {
      line-height: 120%;
	  user-select: none;
	  -webkit-user-select: none;   /* Safari */
      -moz-user-select: none;      /* Firefox */
      -ms-user-select: none;       /* Internet Explorer/Edge */
    }
  </style>
</head>
<body>
	<pre id="canvas"></pre>
	
	<script>
	  // Canvas dimensions (matching the original terminal version)
	  const width = 160, height = 44;
	  const totalPixels = width * height;
	  
	  // Projection constants
	  const distanceFromCam = 100;
	  const K1 = 40;
	  const horizontalOffset = 0;
	  
	  // Automatic rotation speed (when not dragging)
	  const autoRotX = 0.01;
	  const autoRotY = 0.01;
	  const autoRotZ = 0.01;
	  
	  // Buffers for the ASCII frame and for depth (z-buffer)
	  let buffer = new Array(totalPixels);
	  let zBuffer = new Array(totalPixels);
	  const backgroundASCIICode = ' ';
	  
	  // We use a 3x3 rotation matrix to represent the cube's orientation.
	  // The matrix is stored as an array of 9 elements (row-major order):
	  // [r00, r01, r02, r10, r11, r12, r20, r21, r22]
	  let orientation = [1, 0, 0,
						 0, 1, 0,
						 0, 0, 1];
	  
	  // For arcball dragging
	  let dragging = false;
	  let initialOrientation = null; // Copy of orientation when drag starts
	  let arcStartVec = null;        // Arcball vector at the start of dragging
	  
	  const canvasElement = document.getElementById("canvas");
	  
	  // Helper: Multiply two 3x3 matrices.
	  function multiplyMatrix(a, b) {
		let result = new Array(9);
		for (let i = 0; i < 3; i++) {
		  for (let j = 0; j < 3; j++) {
			result[i*3+j] = a[i*3+0] * b[0*3+j] +
							a[i*3+1] * b[1*3+j] +
							a[i*3+2] * b[2*3+j];
		  }
		}
		return result;
	  }
	  
	  // Helper: Rotation matrix around X-axis
	  function rotationMatrixX(angle) {
		const c = Math.cos(angle), s = Math.sin(angle);
		return [1, 0, 0,
				0, c, -s,
				0, s, c];
	  }
	  
	  // Helper: Rotation matrix around Y-axis
	  function rotationMatrixY(angle) {
		const c = Math.cos(angle), s = Math.sin(angle);
		return [c, 0, s,
				0, 1, 0,
				-s, 0, c];
	  }
	  
	  // Helper: Rotation matrix around Z-axis
	  function rotationMatrixZ(angle) {
		const c = Math.cos(angle), s = Math.sin(angle);
		return [c, -s, 0,
				s, c, 0,
				0, 0, 1];
	  }
	  
	  // Helper: Create a rotation matrix from an axis (3-element vector) and an angle.
	  function rotationMatrixFromAxisAngle(axis, angle) {
		const norm = Math.hypot(axis[0], axis[1], axis[2]);
		if (norm === 0) return [1,0,0, 0,1,0, 0,0,1];
		const [x, y, z] = [axis[0] / norm, axis[1] / norm, axis[2] / norm];
		const c = Math.cos(angle), s = Math.sin(angle), t = 1 - c;
		return [
		  t*x*x + c,     t*x*y - s*z,   t*x*z + s*y,
		  t*x*y + s*z,   t*y*y + c,     t*y*z - s*x,
		  t*x*z - s*y,   t*y*z + s*x,   t*z*z + c
		];
	  }
	  
	  // Helper: Transform a 3D point by the current orientation matrix.
	  function transformPoint(x, y, z) {
		return [
		  orientation[0]*x + orientation[1]*y + orientation[2]*z,
		  orientation[3]*x + orientation[4]*y + orientation[5]*z,
		  orientation[6]*x + orientation[7]*y + orientation[8]*z
		];
	  }
	  
	  // Arcball mapping: maps the mouse position to a 3D point on a unit sphere.
	  function getArcballVector(clientX, clientY) {
		const rect = canvasElement.getBoundingClientRect();
		// Map mouse coordinates so that the center is (0,0) and the range is [-1,1]
		let x = -1 * (clientX - rect.left - rect.width / 2) / (rect.width / 2);
		let y = (rect.height / 2 - (clientY - rect.top)) / (rect.height / 2); // invert y for typical canvas coordinates
		let z2 = 1 - x*x - y*y;
		let z = z2 > 0 ? Math.sqrt(z2) : 0;
		return [x, y, z];
	  }
	  
	  // Vector cross product (3-element vectors)
	  function cross(v1, v2) {
		return [
		  v1[1]*v2[2] - v1[2]*v2[1],
		  v1[2]*v2[0] - v1[0]*v2[2],
		  v1[0]*v2[1] - v1[1]*v2[0]
		];
	  }
	  
	  // Vector dot product
	  function dot(v1, v2) {
		return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
	  }
	  
	  // --- Event Listeners for Dragging (Arcball rotation) ---
	  canvasElement.addEventListener("mousedown", (e) => {
		dragging = true;
		canvasElement.style.cursor = "grabbing";
		arcStartVec = getArcballVector(e.clientX, e.clientY);
		initialOrientation = orientation.slice();  // make a copy
	  });
	  
	  canvasElement.addEventListener("mousemove", (e) => {
		if (dragging) {
		  const arcCurrentVec = getArcballVector(e.clientX, e.clientY);
		  // Compute the rotation axis and angle from the start vector to current vector.
		  const axis = cross(arcStartVec, arcCurrentVec);
		  let angle = Math.acos(Math.min(1.0, dot(arcStartVec, arcCurrentVec)));
		  // If there's little movement, avoid updating.
		  if (!isNaN(angle) && Math.abs(angle) > 1e-6) {
			// Compute the incremental rotation matrix.
			const rotInc = rotationMatrixFromAxisAngle(axis, angle);
			// Update orientation: new orientation = incrementalRotation * initialOrientation
			orientation = multiplyMatrix(rotInc, initialOrientation);
		  }
		}
	  });
	  
	  // End dragging on mouseup or when leaving the canvas.
	  canvasElement.addEventListener("mouseup", () => {
		dragging = false;
		canvasElement.style.cursor = "grab";
	  });
	  canvasElement.addEventListener("mouseleave", () => {
		dragging = false;
		canvasElement.style.cursor = "grab";
	  });
	  
	  // --- Projection function: transform a 3D point and update the ASCII buffer ---
	  function calculateForSurface(cubeX, cubeY, cubeZ, ch) {
		// Transform the point using the current orientation matrix.
		const point = transformPoint(cubeX, cubeY, cubeZ);
		let x = point[0], y = point[1], z = point[2] + distanceFromCam;
		if (z === 0) z = 1e-6;
		const ooz = 1 / z;
		const xp = Math.trunc(width/2 + horizontalOffset + K1 * ooz * x * 2);
		const yp = Math.trunc(height/2 + K1 * ooz * y);
		const idx = xp + yp * width;
		if (xp >= 0 && xp < width && yp >= 0 && yp < height) {
		  if (ooz > zBuffer[idx]) {
			zBuffer[idx] = ooz;
			buffer[idx] = ch;
		  }
		}
	  }
	  
	  // --- Render Loop ---
	  function render() {
		buffer.fill(backgroundASCIICode);
		zBuffer.fill(0);
		
		// When not dragging, apply a small automatic rotation.
		if (!dragging) {
		  const rotX = rotationMatrixX(autoRotX);
		  const rotY = rotationMatrixY(autoRotY);
		  const rotZ = rotationMatrixZ(autoRotZ);
		  // Compose the incremental rotations (order matters)
		  orientation = multiplyMatrix(rotZ, multiplyMatrix(rotY, multiplyMatrix(rotX, orientation)));
		}
		
		// Iterate over points to render the six cube faces.
		for (let cubeX = -20; cubeX < 20; cubeX += 0.5) {
		  for (let cubeY = -20; cubeY < 20; cubeY += 0.5) {
			calculateForSurface(cubeX, cubeY, -20, '@');  // Front face
			calculateForSurface(20, cubeY, cubeX, '$');    // Right face
			calculateForSurface(-20, cubeY, -cubeX, '~');   // Left face
			calculateForSurface(-cubeX, cubeY, 20, '#');    // Back face
			calculateForSurface(cubeX, -20, -cubeY, ';');   // Bottom face
			calculateForSurface(cubeX, 20, cubeY, '+');      // Top face
		  }
		}
		
		// Build the output string line by line.
		let output = "";
		for (let y = 0; y < height; y++) {
		  let line = "";
		  for (let x = 0; x < width; x++) {
			line += buffer[x + y * width];
		  }
		  output += line + "\n";
		}
		canvasElement.innerText = output;
		requestAnimationFrame(render);
	  }
	  
	  render();
	</script>
  </body>
  </html>
